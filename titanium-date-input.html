<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../paper-input/paper-input-behavior.html">
<link rel="import" href="../paper-input/paper-input-container.html">
<link rel="import" href="../iron-input/iron-input.html">
<link rel="import" href="../paper-input/paper-input-error.html">
<link rel="import" href="../iron-form-element-behavior/iron-form-element-behavior.html">
<link rel="import" href="../iron-input/iron-input.html">
<link rel="import" href="../paper-input/paper-input.html">
<link rel="import" href="../moment-element/moment-import.html">
<!--
`titanium-date-input`


@demo demo/index.html
-->
<dom-module id="titanium-date-input">
    <template>
        <style>
             :host {
                display: block;
            }

            paper-input {
                width: 100%;
                --paper-input-container: {
                    padding-bottom: 0;
                }
                ;
            }
        </style>
        <paper-input id="input" always-float-label placeholder="[[placeholder]]" validator="[[validator]]" label="[[label]]" error-message="[[errorMessage]]"
            required="[[required]]" allowed-pattern="[0-9\/]" maxlength="10" value="{{value}}" invalid="{{invalid}}" disabled="[[disabled]]"
            focused="{{focused}}">
            <slot name="prefix" slot="prefix"></slot>
            <slot name="suffix" slot="suffix"></slot>
        </paper-input>
    </template>

    <script>
        'use strict';
        class TitaniumDateInput extends Polymer.mixinBehaviors([Polymer.IronFormElementBehavior],
            Polymer.Element) {
            static get is() {
                return 'titanium-date-input';
            }

            static get properties() {
                return {
                    label: {
                        type: String
                    },
                    value: {
                        type: String,
                        notify: true,
                        observer: '_valueChanged'
                    },
                    invalid: {
                        type: Boolean,
                        value: false,
                        notify: true
                    },
                    autoValidate: {
                        type: Boolean,
                        notify: true
                    },
                    required: {
                        type: Boolean,
                        notify: true
                    },
                    disabled: {
                        type: Boolean,
                        value: false
                    },
                    datePattern: {
                        type: String,
                        value: 'MM/DD/YYYY'
                    },
                    placeholder: {
                        type: String,
                        value: 'mm/dd/yyyy'
                    },
                    date: {
                        type: Object,
                        value: {},
                        notify: true
                    },
                    errorMessage: {
                        type: String
                    },
                    focused: {
                        type: Boolean,
                        notify: true
                    },
                    validator: {
                        type: String
                    }
                };
            }

            static get observers() {
                return [
                    '_onFocusedChanged(focused)'
                ];
            }

            connectedCallback() {
                super.connectedCallback();
                var regex = '';
                regex = this.datePattern.replace(/\s/g, '\\s');
                regex = regex.replace(/M/gi, '\d');
                regex = regex.replace(/D/gi, '\\d');
                regex = regex.replace(/Y/gi, '\\d');
                regex = regex.replace(/\+/g, '\\+');
                this.$.input.pattern = regex;
            }

            _valueChanged(value, oldValue) {
                if (typeof value === "object")
                    value = moment(value, "MM/DD/YYYY").format("MM/DD/YYYY");

                if (!value || value === oldValue)
                    return;

                let originalString = value ? value.toString() : '';

                let start = this.$.input.selectionStart;
                let initialSlashesBeforeCaret = originalString.substr(0, start).split('/').length - 1;
                originalString = originalString.replace(/\//g, '');
                let shouldFormat = originalString.length <= this.datePattern.replace(/\//g, '').length;
                let formattedValue = '';
                let currentSlashIndex = 0;
                let totalSlashesAdded = 0;
                for (let i = 0; i < originalString.length; i++) {
                    currentSlashIndex = this.datePattern.indexOf('/', currentSlashIndex);
                    if (shouldFormat && i == (currentSlashIndex - totalSlashesAdded)) { // jshint ignore:line
                        formattedValue += '/';
                        currentSlashIndex++;
                        totalSlashesAdded++;
                    }
                    formattedValue += originalString[i];
                }
                let updatedSlashesBeforeCaret = formattedValue.substr(0, start).split('/').length - 1;
                let slashesDifference = updatedSlashesBeforeCaret - initialSlashesBeforeCaret;
                this.updateValueAndPreserveCaret(formattedValue.trim());
                this.$.input.selectionStart = this.$.input.selectionEnd = start + slashesDifference;

                if (this.autoValidate)
                    this.validate();
            }

            updateValueAndPreserveCaret(newValue) {
                try {
                    var start = this.inputElement.selectionStart;
                    this.value = newValue;
                    this.inputElement.selectionStart = start;
                    this.inputElement.selectionEnd = start;
                } catch (e) {
                    this.value = newValue;
                }
            }

            _onFocusedChanged(focused) {
                if (!focused && this.autoValidate)
                    this.validate();
            }

            validate() {
                let valid = this.$.input.validate();
                if (this.value && this.value.length === 10) {
                    this.invalid = !(moment(this.value, this.datePattern, true).isValid()); // jshint ignore:line
                } else {
                    this.invalid = !valid;
                }
                return !this.invalid && valid;
            }
        }
        customElements.define(TitaniumDateInput.is, TitaniumDateInput);
    </script>
</dom-module>